# Plan for Application Deployment (Issue #13)

This document outlines the plan to implement application deployment per classroom.

## 1. Understand Application and Classroom Configuration

*   **Analyze `etc/samples/class_with_apps.yaml`:** I will start by examining this file to understand how applications are defined within a classroom configuration. This will reveal the structure of application specifications, including their names, variables, and any other relevant parameters.
*   **Examine `applications/foobar`:** I will inspect the `foobar` application directory to understand the expected structure of an application. This includes the `blueprint.yaml` file, and the `start.sh`, `stop.sh`, and `status.sh` scripts.

## 2. Implement Application Prerequisite Checks

*   **Develop a Python script (`bin/prepare_app_deployment.py`):** This script will be responsible for preparing the application deployment.
*   **Prerequisite Check Logic:** The script will iterate through the applications specified in the classroom YAML and for each application, it will:
    *   Verify the existence of the application's directory in `applications/`.
    *   Check for the presence of `blueprint.yaml`, `start.sh`, `stop.sh`, and `status.sh` in the application's directory.
    *   If any of these checks fail, it will log an `_APP_MALFORMED_` error for that application and continue to the next.

## 3. Environment Variable Management

*   **Hierarchical Environment Variable Resolution:** The script will resolve environment variables in the following order of precedence (lowest to highest):
    1.  Class-level variables.
    2.  Project-level variables.
    3.  Autogenerated variables (`GOOGLE_CLOUD_PROJECT`, `SANDMOLD_DESK_TYPE`).
*   **Blueprint Variable Check:** The script will compare the resolved environment variables with the `spec.variables` in the application's `blueprint.yaml` to ensure all required variables are present. If not, it will log an error.

## 4. Terraform Integration

*   **Generate `app_deployment.json`:** The Python script will generate a JSON file (`tmp/app_deployment.json`) that will serve as the input for Terraform. This file will contain a list of applications to be deployed for each project, along with the necessary environment variables.
*   **Terraform `local-exec`:** I will use Terraform's `local-exec` provisioner within the `2_apps_deployment` module to execute the `start.sh` script for each application.
*   **Terraform Variables:** The `app_deployment.json` will be passed as a variable to the Terraform module.

## 5. Testing and Validation

*   **`foobar` Success Case:** I will configure the `class_with_apps.yaml` to ensure the `foobar` application has all the necessary configurations to be deployed successfully.
*   **Failure Case:** I will introduce an application with a missing script or environment variable to test the error handling and reporting.
*   **Terraform Execution:** I will run `terraform apply` for the `2_apps_deployment` module and verify that the `foobar` application is deployed correctly and the failing application is reported as expected.

## 6. Update Documentation and Create Pull Request

*   **Update `README.md`:** I will update the relevant documentation to reflect the new application deployment functionality.
*   **Create Pull Request:** I will create a pull request, linking it to issue #13, and request a review.
